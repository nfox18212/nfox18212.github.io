<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>CSE379 Lab 7 Documentation</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">CSE379 Lab 7 Documentation</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="data-structures-overview"><a class="header" href="#data-structures-overview">Data Structures Overview</a></h1>
<p>We will be manually creating multiple data structures and subrotuines to handle these data structures. All of these data structures will be built first before all other subroutines to allow us to work with some level of abstraction.  The data structures created will be matrices and three lookup tables.</p>
<h2 id="matrices"><a class="header" href="#matrices">Matrices</a></h2>
<p>Seven matrices will be used, with six of these matrices representing the six faces of the cube.  The seventh matrix will be the display matrix, the only matrix that will actually be rendered.  These matrices will store metadata and data that contain information about the face number, the cell index in row,column format and the color contents of the cell.</p>
<p>The display matrix will contain the player's avatar, and will be a copy of one of the six face matrices, except with a rotation imposed on it depending on the player's orienation.  To assist with this, three key linear algebra operations will be implemented:  Row Reflection, Column Reflection, and Transposition.  More information can be found in the <a href="data/board/rot.html">Rotation and Player Orientation</a> chapter. <!-- This should convert and link to the compiled html page --></p>
<h2 id="lookup-tables"><a class="header" href="#lookup-tables">Lookup Tables</a></h2>
<p>Three lookup tables will be created to simplify the logic: the Adjacency List (a-list), the Face Orientation table (foTab), and the Relative to Cardinal Direction table (rcdTab).  Important information will be stored in these tables, and multiple subroutines will be written to access the data in them.  Details about the latter two tables are described <a href="data/./tables.html">here</a>.</p>
<h3 id="adjacency-list"><a class="header" href="#adjacency-list">Adjacency List</a></h3>
<p>The a-list is a lookup table that specifies what each cell is adjacent to.  There will always be four other cells that are adjacent to the current cell, one for each of the cardinal directions.  The direction is specified both within the assembly implementation of it, and in the pattern.  The pattern used through is East-South-North-West.  So if you go to Cell ID 400 and go to offset 4, you will be looking for the cell to the West of Cell 400.  Details of implementation will be <a href="data/./alist.html">here</a>.</p>
<h3 id="face-orientation-table"><a class="header" href="#face-orientation-table">Face Orientation Table</a></h3>
<p>The foTab is a lookup table that tells you what the player's new orientation will be given the current face and the move the player is moving to.  For example, if the player is on Face 2 and moves to Face 6, the player will experience a rotation of 270 degrees.  This table is based off of the orthographic projection of the cube and is easiest to understand if you have a physical object such as a Rubik's cube to mimic the rotation change.  More details are found in <a href="data/../board/rot.html">the rotation section</a>.</p>
<h3 id="relative-to-cardinal-direction-table"><a class="header" href="#relative-to-cardinal-direction-table">Relative to Cardinal Direction Table.</a></h3>
<p>The rcdTable is a lookup table that converts relative directions to the absolute, cardinal directions.  Relative directions are what the player inputs, up down left right from the w, a, s, and d keys.  Because what cell the player will move to when inputting a direction will change based on orientation, having some form of absolute direction to use as a stable index is vital.</p>
<h2 id="cells"><a class="header" href="#cells">Cells</a></h2>
<p>The cells table is a list of every cell ID in the adjacency list, in order.  There are no associated subroutines that manipulate it directly, but it is used by the routine to fill the board with random colors.</p>
<h2 id="player-data"><a class="header" href="#player-data">Player Data</a></h2>
<p>This is a word stored in memory declared in lab_7.s.  It contains basic information about the state of the player.  The most-significant byte contains the player's orientation; the second most significant byte contains the player's current color; and the last two bytes contain the player's current position as a cell ID.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="matrices-1"><a class="header" href="#matrices-1">Matrices</a></h1>
<p>Multiple linear algebra subroutines will be implented to do basic linear algebra operations.  It will be stored as a contiguous block of memory, but these subroutines will allow us to abstract it away.</p>
<h2 id="matrix-metadata"><a class="header" href="#matrix-metadata">Matrix Metadata</a></h2>
<p>The specific data type will be stored as "metadata" just before the first cell by pushing forward the offset by 4 bytes.  This gives a word of metadata to store information about what a particular instance of a matrix is used for, such as what face of the Rubiks Cube it represents.</p>
<p>For example, storing a 1 in this metadata will indicate the associated matrix is a matrix of half-words, meaning each cell will contain 2 bytes of data.</p>
<p>All the matrices used will start by using the .space assembler directive to allocate and clear enough memory to store the matrix.</p>
<h2 id="indexing"><a class="header" href="#indexing">Indexing</a></h2>
<p>An index macro will be implemented to access these matrices by taking in two coordinate values, row and column, and calculating the offset in memory based on that information.  It will read the word of metadata to determine the size of each cell and take that into account when determining the offset.</p>
<p>Once the offset has been determined, it will load one cell of memory into register r0 and return that.</p>
<h2 id="reflection-and-transposition"><a class="header" href="#reflection-and-transposition">Reflection and Transposition</a></h2>
<p>Clever iterating within a for loop will allow us to do matrix reflections.  Using example in Python for clarity:</p>
<pre><code class="language-python">import numpy as np
def main():
    oldMat = np.array([
        [1,2,3],
        [4,5,6],
        [7,8,9]
    ])
</code></pre>
<p>The standard way to iterate through this matrix with a for loop would be with incrementing rows and incrementing columns.  An example would be copying the old matrix into a new matrix.</p>
<pre><code class="language-python">    newMat = np.zeros([3,3])

    for row in [0,1,2]:
        for col in [0,1,2]:
            newMat[row][col] = oldMat[row][col]

</code></pre>
<pre><code>newMat = [[1,2,3],[4,5,6],[7,8,9]]
</code></pre>
<p>Just by changing the order of iteration, we can preform reflections and transposition.  If you start at row 2 and iterate down, you can preform a reflection over row 1.</p>
<pre><code class="language-python">def rowReflection(mat):
    shape = np.shape(mat)
    numRows = shape[0] - 1
    numCols = shape[1] - 1
    newMat = np.zeros([3,3])

    for row in range(3):
        for col in range(3):
            newMat[row,col] = mat[numRows - row,col]
    return newMat
</code></pre>
<pre><code>newMat = [[7. 8. 9.], [4. 5. 6.], [1. 2. 3.]]
</code></pre>
<p>This method can also be used to preform column reflections, and transposition.  Composing these operations will allow for rotation.  This will be implemented in ARM using conditionally executing branches.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lookup-tables-1"><a class="header" href="#lookup-tables-1">Lookup Tables</a></h1>
<p>Three lookup tables have been created to assist with the development of this project: <a href="data/./alist.html">the adjacency list</a>, the Face Orientation Table and the Relative to Cardinal Direction Table.  This file will describe the format of the foTab and rcdTab.</p>
<h2 id="relative-to-cardinal-direction-table-1"><a class="header" href="#relative-to-cardinal-direction-table-1">Relative to Cardinal Direction Table</a></h2>
<p>The Relative to Cardinal Direction Table is stored as a half-word array in the format:
<img src="data/../images/rcdtab.png" alt="rcdtab" /></p>
<ul>
<li>Padding is just bits that are not used for anything but allow the data structure to adhere to word half-word alignment.</li>
<li>"Player Or." stands for Player Orientation, which is a value 0-3.  More information can be found in <a href="data/../board/rot.html">the rotation docs</a>.</li>
<li>The 4 directional pairs are static and will always be in this pattern. You use this by translating the player's inputted direction, and those two bits will contain a number 0-3 that represents the corresponding cardinal direction.</li>
</ul>
<h3 id="rcdtab-subroutines"><a class="header" href="#rcdtab-subroutines">rcdTab Subroutines</a></h3>
<p><strong>rcd</strong>:
This subroutine takes in the current orientation of the character in r0 and the relative movement (wasd).  It converts wasd into NSEW by using mulitple IT blocks to calculate the offset to load a byte into the rcdtab.  It returns the absolute character that represents the direction the character is travelling in.</p>
<h2 id="face-orientation-table-1"><a class="header" href="#face-orientation-table-1">Face Orientation Table</a></h2>
<p>The Face Orientation Table is a lookup table that stores what the player's new orientation will be when moving between faces.  When moving from one face to another face, the player's orienation may change.  This table will describe how it changes.  The format is described below:</p>
<p><img src="data/../images/fotab.png" alt="fotab" /></p>
<ul>
<li>Again, padding is just 0 bits that do not store data.</li>
<li>New FID and Old FID are the face that the player is moving <em>to</em> and the face the player is moving <em>from</em> respectively.</li>
<li>Cardinal direction represents the Cardinal direction needed to go from the current face onto the new face.
<ul>
<li>Encoded for redundancies' sake.</li>
</ul>
</li>
<li>New O. represents the new orientation of the player.  When moving from any face A to face B, the player may rotate their frame of view, depending on what faces A and B are.  This is useful for when the board must be rotated.</li>
</ul>
<h3 id="fotab-subroutines"><a class="header" href="#fotab-subroutines">fotab subroutines</a></h3>
<p><strong>new_o</strong>
New Orientation takes in a cell as a CID in r0 and the direction of movement the character is going to travel in r1.  It returns the new orientation of the character in r2.  It uses the previously described face orientation table to determine what the new orientation will be.  The given character in r1 <strong>must</strong> be n, s, e, or w or else the program will crash.</p>
<h3 id="utility-subroutines"><a class="header" href="#utility-subroutines">Utility Subroutines</a></h3>
<p><strong>extract_cid</strong>
Extract Cell ID is a utility subroutine that takes in a cell ID and extracts it, using the inverse of the formula to create a CID - 100<em>Face Number + 10</em>Row Number + Column Number.  So extract cid takes the cell ID and divides it by 100 and stores the quotient into r0. Then divide it by 10 and store it in r1.  Finally, it stores the remainder in r2.  Extract cid divides using the div_and_mod library subroutine.</p>
<p><strong>dirindex</strong>
Dirindex is a small subroutine that was written because the standard of representing direction as 0123 to nsew, nsew to 0123, wasd to 10, 11, 12, 13.  It also converts 0x10, 0x11, 0x12, 0x13 to wasd.  All it does is convert between the various standards.
0 -&gt; e, 1 -&gt; s, 2 -&gt; n, 3 -&gt; w.
0x10 -&gt; a, 0x11 -&gt; s, 0x12 -&gt; w, 0x13 -&gt; d.
a -&gt; 10, s -&gt; 11, w -&gt; 12, d -&gt; 13.
e -&gt; 0, s -&gt; 1, n -&gt; 2, w -&gt; 3</p>
<p>The relative direction conversions were not used in the final version.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="adjaceny-list"><a class="header" href="#adjaceny-list">Adjaceny List</a></h1>
<p>To store what cell is adjacent to what cell, to easily determine what color is an adjacent cell, an adjacency list will be constructed.</p>
<p>This adjacency list will store the address in memory of each cell that is adjacent to the indexed cell.  For example, if we look to see what's adjacent to cell 500, we would index and find a list that contains the addresses cells 501, 510, 400, and 320.  The order of these is important, as this tells us the cardinal direction you travel to access it.  501 is East, 510 is South, 400 is North, and 320 is West.</p>
<p>These cardinal projections are based on the orthographic, flattened projection of the Rubiks cube.  Absolute North is equivalent to moving up on Face 1 with zero rotation.  Each cell has an identifier of the face number, and cell number.  The player's direction, stored as a byte, will translate the Up, Down, Left, Right from w, a, s, and d into N, S, E, W using a lookup table.</p>
<p>Currently, we are going to store 30 out of the 54 cells.  The reason is because for 24 cells, we don't need to store them and can easily calculate them based on the direction of movement and the current cell's index.  We will call these <strong>In-Face Cells</strong>.  Below is a example of it using face 1:</p>
<div class="table-wrapper"><table><thead><tr><th>100</th><th>101</th><th>102</th></tr></thead><tbody>
<tr><td><strong>110</strong></td><td><strong>111</strong></td><td><strong>112</strong></td></tr>
<tr><td><strong>120</strong></td><td><strong>121</strong></td><td><strong>122</strong></td></tr>
</tbody></table>
</div>
<p>If the current cell is in the format XX0 or XX1, then going East will always result in adding 1 to the cell's index.  120 will become 121, 121 will become 122, etc.  The full list of rules is below:</p>
<div class="table-wrapper"><table><thead><tr><th>XX0/XX1</th><th>X0X/X1X</th><th>X2X/X1X</th><th>XX1/XX2</th><th>Dir</th></tr></thead><tbody>
<tr><td>+001</td><td>N/A</td><td>N/A</td><td>N/A</td><td>E</td></tr>
<tr><td>N/A</td><td>+010</td><td>N/A</td><td>N/A</td><td>S</td></tr>
<tr><td>N/A</td><td>N/A</td><td>-010</td><td>N/A</td><td>N</td></tr>
<tr><td>N/A</td><td>N/A</td><td>N/A</td><td>-001</td><td>W</td></tr>
</tbody></table>
</div>
<p>All other movements will need to be indexed using the adjacency list, but this removes the need to specify 24 cells in the .data section of the assembly program.  Less manual work is better.  The mapping of what cell is adjacent to what will be <a href="https://docs.google.com/spreadsheets/d/1lIbhq9RJiK44gera0EY-gOZbGEYBQ-LJChw7v7JewIk/edit?usp=sharing">in this google sheet.</a></p>
<h2 id="color"><a class="header" href="#color">Color</a></h2>
<p>The color is also stored in the alist, but only the indexing cell.  Meaning if you look through the adjacency table for cell 111, the color of cell 111 will be stored at that offset.  As the table is stored in hex, it would look like this if cell 111 was purple:</p>
<pre><code class="language-arm">
.half   0x6F06
</code></pre>
<p>It is stored this way in memory to account for the little endian architecture.  The largest 3 bits in this index stores the color, and the rest is the cell ID.</p>
<h2 id="subroutines"><a class="header" href="#subroutines">Subroutines</a></h2>
<p>The following subroutines are availible for the adjacency list: (as of 2024-04-12)</p>
<p><strong>get_color</strong>: Given an input cell ID in r0, returns the color of that cell in r0.</p>
<p><strong>set_color</strong>:  Given an input CID in r0 and a color in r1, sets the color of that cell to the color givenn in r1.  Returns the new cell value in r0.</p>
<p><strong>extract_cid</strong>:  Given a CID, returns the face number in r0, the row number in r1, nad the column number in r2.</p>
<p><strong>get_cell</strong>:  Given a CID in r0 and a direction in r1, return the given cell from the alist in memory in r0 and the offset it took in r1.  You <strong>must</strong> provide a valid direction (0-4) in r1 or else the subroutine will crash.  Directions: 0 - East, 1 - South, 2 - North, 3 - West, 4 - No movement.  If given 4 in r1, will return the given cell from memory which includes color data.</p>
<p><strong>dirindex</strong>:  Given an input ascii character representing a cardinal direction or a number 0-3 that represents a cardinal direction, returns in r0 the character/integer version.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="linear-algebra"><a class="header" href="#linear-algebra">Linear Algebra</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="random-number-generation"><a class="header" href="#random-number-generation">Random Number Generation</a></h1>
<p>The random number generation is done by taking in an initial seed from Timer 1.  Timer 1 is initialized to a very, very large value instead of a very small value.  The timer must be initialized to a large value, like 0xFFFFFFFE, because it'll increment down every clock cycle.  Once the timer value hits zero, it'll repeat and rollover.  So if you have a small timer period, this will mean that the number of possible values it will take is significantly decreased.  Hence using a large number.</p>
<p>On the first UART interrupt, the UART handler will stop Timer 1, freezing its value.  With this value now being static, we can effectively use it as a seed value.  It is then stored in the label "seeddata" to make accessing it easier.</p>
<p>When filling the board, only the last 6 bits are used as an index.  After the bitmask to grab the last 6 bits, the seed is randomized using a simple Xorshift algorithm.  Xorshift was chosen due to its simplicitly to implement in assembly.  The one difference was that instead of setting the new seed to the time it takes for the randomized version to become the original, the seed is just xorshifted with 7, 13, 5, and 9.  This is because this process happens 1000 times, and getting the new seed with the original process would take an unreasonable amount of time.</p>
<h1 id="filling-the-board"><a class="header" href="#filling-the-board">Filling the Board</a></h1>
<p>To fill the board, a new data structure was created: the color list.  The color list is an array of 54 colors terminated with a 0xFF byte.  In its original form, the color list represents a "solved" version of the rubiks cube.  So the first face is all color 1 (red), the second is all color 2 (green), and so on.  The initial state of the board is pulled directly from iterating through this array and using the cells array to sequentially set each cell to its corresponding entry in the color array.</p>
<p>So naturally, the next question is "how do we randomize the color list?".  This is achieved using the initial seed in seeddata, and masking the for the last 6 bits.  They act as the first index.  The first index is then rotated 29 bits, and checked to see if they are greater than 54 or not using the subroutine <strong>reduce</strong> - we don't want to go out-of-bounds.  Now we have two indices to act as offsets into the color array.  The contents are then swapped.  The seed is randommized using the xorshift algorithm.  This proccess repeats 1000 times.</p>
<h1 id="subroutines-1"><a class="header" href="#subroutines-1">Subroutines</a></h1>
<p><strong>seed</strong>:
Seed does not take in any arguments.  It implements the algorithm described above and is called from the main subroutine.  After 1000 iterations, the subroutine will call <strong>fill_alist</strong>.</p>
<p><strong>fill_alist</strong>:
Fill adjacency list does not take in any arguments.  It iterates through the cells array with a post-indexed load to ensure it gets each cell.  It also loads each color from the color array with a post indexed load.  It then will call <a href="rng/data/alist.html"><strong>set_color</strong></a> using the given cell and color to put it into the adjacency list, which acts as the entire board.</p>
<p>To ensure every cell is filled with a color, two things were implemented data-wise:</p>
<ul>
<li>0 does not represent a color, but the absence of color.  Having it represent a color would be extremely confusing.</li>
<li>0xFF is used as a terminating byte instead of 0x00</li>
</ul>
<p>The iteration will only stop once the 0xFF byte has been read.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="board"><a class="header" href="#board">Board</a></h1>
<p>The board is displayed using a display matrix.  This display matrix was partially implemented by Sebastien.  The colors are stored in the <a href="board/data/alist.html">adjacency list</a>.  Various subroutine interact with the board, changing its state by changing the adjacency list.</p>
<h1 id="subroutines-2"><a class="header" href="#subroutines-2">Subroutines</a></h1>
<p><strong>detect_collisions</strong>:
This subroutine determines if the movement is valid or not.  Using the information passed in of the new cell in r0, the player's color in r1, and returns a 0 or a 1 in r2.  It checks to see if the new cell's color is the same as the player's color that was passed in.  If it is, it returns a 1.  Otherwise, it returns a 0.</p>
<p><strong>check_board_state</strong>:</p>
<p>This subroutine checks the state of the board.  Essentially, it checks to see if any of the faces are completed and if so, how many, by iterating through every single cell in the cell list and calling <a href="board/data/alist.html"><strong>get_color</strong></a>.  It determines the color of the first cell of 9 and checks to see if the next 8 cells all have the same color as the first cell.  If so, it increments the number of completed faces by 1.  Repeat this for the other 5 faces.</p>
<p>After it iterates through the cell list, it</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="board-layout-and-rotation"><a class="header" href="#board-layout-and-rotation">Board Layout and Rotation</a></h1>
<p>The board will be laid out in memory using 7 matrices, and an adjacency list. 6 of these matrices represent the 6 faces of the cube.  The final matrix is the display matrix.  A table will represent the imposed rotation when the character moves between faces, if any.  The current character's orientation will be stored as an integer value 0-3, representing a rotation of 90 degrees times the integer value.</p>
<p>Each cell in the matrix will contain the color of that cell.  When we go to display one of the faces, we will copy the matrix we are displaying into the display matrix, and we will preform a composition of reflections and transposition based on the character's orientation.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rotation"><a class="header" href="#rotation">Rotation</a></h1>
<p>Rotation is implemented by taking the face matrix from memory and doing one or more transposes into row-reflections, which will rotate it by 90 degrees.  This was used to build the <a href="board/../data/alist.html">adjacency list</a>.  The player's orientation is stored in memory as a value from 0-3, representing the number of 90 degree counter clockwise turns the character has taken relative to the absolute North of Face 1.</p>
<p>Two lookup tables will be used to store rotation information.  The Face-Rotation table will take the current Face Number and tells you how the player's orientation will change when they move to a different face.  For example, moving East from Face 6 to Face 2 will cause the Player's orientation value to become 2.  This means compared to Absolute North of Face 1, we need to rotate the matrix containing Face 2 by 180 degrees.  This is achieved by composing two consecutive 90 degree rotations, or transpose -&gt; row reflection -&gt; transpose -&gt; row reflection.</p>
<p>The other lookup table will translate the player's input of wasd into cardinal directions, again based on the player's orientation.  For example, if the player has a orientation value of 1 and moves up, that is a movement East.</p>
<p>The full table can be found <a href="https://docs.google.com/spreadsheets/d/1lIbhq9RJiK44gera0EY-gOZbGEYBQ-LJChw7v7JewIk/edit?usp=sharing">here</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="movement"><a class="header" href="#movement">Movement</a></h1>
<p>The character will move at a rate of two cells per second.  When onto a different face of the cube, the display matrix will pull the adjacent two columns from the new face and display them.  Then, after two game ticks which are half a second have occured, the new face will be fully rendered.</p>
<p>The orientation of the face will be based on the character's orientation, and only the display face's orientation will change.</p>
<h2 id="subroutines-3"><a class="header" href="#subroutines-3">Subroutines</a></h2>
<p><strong>move</strong>:
This subroutine is what actually moves the player.  It does not take in any input, but takes in the player's intended direction of movement from the byte nextMovement, which is declared in handlers.s.  <a href="board/ints/uart.html"><strong>UART0_handler</strong></a> stores the player's next absolute movement as n, s, e, or w.  From these two pieces of information, <strong>move</strong> will calculate the new orientation, using <a href="board/data/tables.html"><strong>new_o</strong></a>.  <strong>Move</strong> uses the nextMovement as an input to <a href="board/data/alist.html"><strong>get_cell</strong></a>.  This gets us the new cell and new orientation.  Then, it calls <a href="board/board/board.html"><strong>detect_collision</strong></a> to check if the player is allowed to move.  If they are, the movement is committed, playerdata is changed and the subroutine exists.  If the movement is invalid, the subroutine simply exists.  Unfortunately, the number of moves is not tracked.  This was forgotten about.</p>
<p>What this subroutine does track is the action type, atype.  If the player moves onto a new face, atype is set to 2.  Otherwise it is set to 1.  Finally, it sets nextMovement to zero.  When nextMovement is zero, there is no movement pending.</p>
<p><strong>swap</strong>:
This subroutine is called whenever the player pushes space.  It sets atype to 3.  It calls <a href="board/data/alist.html"><strong>get_color</strong></a> to find the color of the cell the cursor is currently on and sets the cursor's color to that.  It then sets the cell's color to the player's color.  RGB LEDs were not updated to reflect the player's color.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="display"><a class="header" href="#display">Display</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="interrupts"><a class="header" href="#interrupts">Interrupts</a></h1>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><p>#GPIO</p>
<p>GPIO is used for three things:</p>
<ul>
<li>Pausing using SW1</li>
<li>Displaying the number of completed faces</li>
<li></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="mdbook-documentation-and-github-pages"><a class="header" href="#mdbook-documentation-and-github-pages">mdBook Documentation and GitHub pages</a></h1>
<p>All documentation will be hosted on GitHub pages, publically.  The docs will be written in Markdown and built in mdBook.  A single-file pdf will be used for submission for ABET accredidation purposes.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="division-labor"><a class="header" href="#division-labor">Division Labor</a></h1>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
